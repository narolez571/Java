<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN" "" >
<html>
<head>
<!--

  Copyright (c) 2007 Peter Suggitt

-->
</head>
<body bgcolor="white"> This top level package contains example code for the structural
	patterns, ie those patterns that are used to form structured designs for differing
	problems. This package contains the following specific patterns.
	<ul>
		<li>Adapter pattern - this pattern is similar to the Decorator pattern in that it is
			about the wrapping of objects with others and thus changing their interface. The
			Decorator pattern wraps objects to extend their functionality whereas the
			adapter pattern wraps an object to hide its interface and expose a new (more
			desirable interface). This pattern is all about creating an object interface
			and then mapping it to another objects interface.</li>
		<li>Bridge pattern - </li>
		<li>Composite pattern - in this pattern we create objects in a tree structure with
			nodes and leaves. In doing this all objects (and compositions of objects)in the
			tree can be treated equally irrelevant of the placement within the tree. IN othr
			words this allows us to treat a single object or a tree of objects in exactly the
			same recursive manner. Some good examples of this would be XML trees and
			directory structures.</li>
		<li>Decorator pattern - in this pattern we 'wrap' up an object with another instance
			of the same interface or abstract class. This is used when inheritance is too
			great a job (eg if there are too many posibilities) and thus an element of wrapping
			of an object is more powerfull than inheritance (can only inherit from one
			class). So for example if we have an object deriving from an interface containing
			a method called foo(), we then create a wrapper object that also derives from that
			object that will first call the inner foo() andthen its local impl of foo().</li>
		<li>Facade pattern - in this pattern we create a class that will simplify a collection
			of interfaces into a consolidated and more simple one. The existing interfaces
			remain but a new, more simple one also exists to remove some of the complexities
			from the existing interfaces. The most common implementation of this would be to
			put a high level interface above an entire subsystem so that there is a common
			client interface to that functionality (and thus an entire subsystem can be
			replaced more easily).</li>
		<li>Flyweight pattern - </li>
		<li>Proxy pattern - </li>
	</ul>
	<h2>Package Specification</h2>
	
	<h2>Related Documentation</h2>
	
	<!-- Put @see and @since tags down here. --> </body>
</html>
